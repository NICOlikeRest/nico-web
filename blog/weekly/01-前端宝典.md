# js部分

## 手动实现unshift

unshift就是数组头插

```js
let arr =  [1,2,3]

// 实现结果
arr.myUnshift(3,4,5) // 3,4,5,1,2,3

// 使用原型的方法
Array.prototype.myUnshift = function () {
    const len = arguments.length;
    for (let i=len-1; i>=0; i--) {
        const element = arguments[i];
        this.splice(0, 0, element); // 实现头插
    }
    
    return this.length;
}
```



## 数组去重

- set去重
- 遍历去重

- filter去重

### 举例

假设你有一个数组 `[1, 2, 2, 3, 4, 4, 5]`，我们来看一下 `myUnique` 方法是如何处理它的：

1. 对于 `1`，`indexOf(1)` 返回 `0`，当前索引也是 `0`，所以保留 `1`。
2. 对于 `2`，`indexOf(2)` 返回 `1`，当前索引也是 `1`，所以保留 `2`。
3. 对于第二个 `2`，`indexOf(2)` 仍然返回 `1`，但当前索引是 `2`，所以过滤掉第二个 `2`。
4. 对于 `3`，`indexOf(3)` 返回 `3`，当前索引也是 `3`，所以保留 `3`。
5. 对于 `4`，`indexOf(4)` 返回 `4`，当前索引也是 `4`，所以保留 `4`。
6. 对于第二个 `4`，`indexOf(4)` 仍然返回 `4`，但当前索引是 `5`，所以过滤掉第二个 `4`。
7. 对于 `5`，`indexOf(5)` 返回 `6`，当前索引也是 `6`，所以保留 `5`。

最终，返回的新数组是 `[1, 2, 3, 4, 5]`，成功地去除了重复项。

```js
// set去重
Array.prototype.myUnique = function () {
    return Array.from(new Set(this))
}

// 遍历去重
Array.prototype.myUnique = function () {
    let arr = [];
    for (let i=0; i<this.length; i++) {
        if (!arr.includes(this[i])) {
            arr.push(this[i]);
        }
    }
    return arr;
}

// filter去重
Array.prototype.myUnique = function () {
    return this.filter((v, idx) => {
        return this.indexOf(v, 0) === idx;
    })
}
```



## 获取指定范围内的随机数

```js
function fn(min, max) {
    // (min, max)
    return Math.round(Math.Random() * (max-min-2) + min + 1)
    // [min, max]
    return Math.round(Math.Random() * (max-min) + min)
    // (min, max]
    return Math.ceil(Math.Random() * (max-min) + min)
    // [min, max)
    return Math.floor(Math.random() * (max-min) + min)
}
```



## 如何提取url中的参数

```js
let url = 'https://alibaba.com?a=1&b=2&c=3#hash'

function queryURLParams(URL) {
    let url = URL.split('?')[1];
    const urlSearchParams = new URLSearchParams(url);
    const params = Object.fromEntries(urlSearchParams.entries())
    
    return params;
}
```



## 如何数组的随机排序

- 遍历数组

```js
function result(arr) {
    for (let i=0; i<arr.length; i++) {
        let randomIdex = parseInt(math.random() * arr.length);
        
        // 交换位置
        let curNum = arr[i];
        arr[i] = arr[randomIndex];
        arr[randomIndex] = curNum;
    }
    
    return arr;
}
```

- 借助sort

```js
arr.sort(() => Math.random() - 0.5)
```



## 实现flatten

```js
let arr = [1,2,[3,4,5,[6,7],8],9,10]
// 方法1 遍历
const flatten = function (arr) {
    while (arr.some(v => Array.isArray(v))) {
        arr = [].concat(...arr);
    }
    return arr;
}

// 方法2 递归
const flatten = function (arr) {
    return [].concat(...arr.map(v => (Array.isArray(v) ? flatten(v) : v)))
}
```



## 给a b c三个请求，希望c在a b后再请求

```js
function requestA() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('Request A completed');
            resolve('Result from A');
        }, 1000); // 模拟请求时间
    });
}

function requestB() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('Request B completed');
            resolve('Result from B');
        }, 1000); // 模拟请求时间
    });
}

function requestC() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('Request C completed');
            resolve('Result from C');
        }, 1000); // 模拟请求时间
    });
}

Promise.all([requestA(), requestB()])
    .then(results => {
        console.log('Requests A and B completed:', results);
        return requestC();
    })
    .then(resultC => {
        console.log('Request C completed:', resultC);
    })
    .catch(error => {
        console.error('Error in one of the requests:', error);
    });

```



## 发布订阅

```js
class EventEmitter {
    // 用来存储事件类型和对应的处理函数
    handlers = {};
    
    /**
     * 注册事件处理函数
     * @param {string} type - 事件类型
     * @param {function} handler - 事件处理函数
     * @param {boolean} once - 是否只触发一次
     */
    on(type, handler, once = false) {
        // 如果当前不存在这个事件类型，则初始化为一个空数组
        if (!this.handlers[type]) {
            this.handlers[type] = [];
        }
        
        // 如果处理函数不在当前事件类型的处理函数数组中，则添加
        if (!this.handlers[type].includes(handler)) {
            this.handlers[type].push(handler);
            // 标记是否只触发一次
            handler.once = once;
        }
    }
    
    /**
     * 注册只触发一次的事件处理函数
     * @param {string} type - 事件类型
     * @param {function} handler - 事件处理函数
     */
    once(type, handler) {
        this.on(type, handler, true);
    }
    
    /**
     * 注销事件处理函数
     * @param {string} type - 事件类型
     * @param {function} handler - 事件处理函数
     */
    off(type, handler) {
        if (this.handlers[type]) {
            // 过滤掉要移除的处理函数
            this.handlers[type] = this.handlers[type].filter(h => {
                return h !== handler;
            });
        }
    }
    
    /**
     * 触发事件
     * @param {string} type - 事件类型
     */
    trigger(type) {
        if (this.handlers[type]) {
            // 遍历所有处理函数并调用它们
            this.handlers[type].forEach(handler => {
                handler.call(this);
                
                // 如果处理函数只触发一次，则在调用后移除
                if (handler.once) {
                    this.off(type, handler);
                }
            });
        }
    }
}

```

# css部分

## BFC

BFC 独立布局环境，也就是外面包了一层，内部元素布局，与外部互不影响

如何实现

- 设置浮动
- overflow auto scroll hidden
- position abso fixed

应用

- 解决浮动元素 令父元素高度坍塌
- 解决非浮动元素被浮动元素覆盖
- 外边距垂直方向重合问题



## flex布局

flexible box 弹性布局 display: flex

- flex-direction 主轴
- flex-wrap 如何换行
- flex-flow  是 flex-direction 和 flex-wrap 属性的复合属性 row nowrap
- justify-content 主轴对齐方式
- align-items 交叉轴对齐方式
- align-content 多根轴线对齐方式



子元素属性

- order 排列顺序
- flex-grow 放大比例 0
- flex-shrink 缩小 1 空间不足 缩小
- flex-basis  flex 元素在主轴方向上的初始大小
- flex 默认 0 1 auto

```js
flex-grow:扩展，默认为0，即表示如果有剩余空间，也不放大
flex-shrink: 收缩，默认为1， 即表示如果空间不足，将项目缩小
flex-basis: 项目的长度，在分配多余空间之前，项目占据主轴空间，相当于我们设置的width
```



## opacity: 0 visibility: hidden display: none

### 结构

display: none 完全消失 不占任何空间 不能点击

visibility: hidden 不会消失 占据空间 内容不可见 不能点击

opacity: 0 占据空间 内容不可见 可点击

### 继承

- display: none opacity: 0 非继承属性
- visibility: hidden 继承属性

### 性能

使用visibility:hidden比display:none性能上要好

display:none切换显示时，页面产生回流（回流:当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流）

visibility切换是否显示时则不会引起回流，opacity页面不会产生回流。



## 文本溢出

### 单行溢出

```css
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

### 多行溢出

```css
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-box-clamp: 3;
overflow: hidden;
```

`display: -webkit-box;`
这是一个旧的弹性盒子显示类型，属于较早的CSS弹性布局规范。它是WebKit引擎特有的实现，用于设置元素为弹性盒子模型。

`-webkit-box-orient: vertical;`
这个属性决定了盒子的子元素是垂直排列还是水平排列。这里设置为`vertical`，意味着子元素将垂直排列。

`-webkit-box-clamp: 3;`
这个属性用来限制盒子中的文本行数。在这里设置为`3`，意味着文本内容将被截断为最多三行。如果内容超过三行，多出的文本将被隐藏。

`overflow: hidden;`
这个属性设置元素内容超出其框时的剪裁方式。`hidden`值表示超出部分将被隐藏，不可见。



## position:sticky实现粘性布局

元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。



## png8/png24/png32区别，压缩原理

- png8 2^8 大小 存储一张图片的颜色种类 256 种 颜色
- png24 rgb 256 x 256 x 256 种颜色
- png32 png24+颜色透明值 rgba

### png压缩

1. 预解析与预处理

在实际进行压缩之前，PNG图像经历预解析和预处理阶段，目的是为压缩算法优化图像数据：

- **色彩深度缩减**：如果图像中使用的颜色不是非常丰富，可以减少色彩深度（比如从24位降到8位），这样可以显著减少数据量。
- **滤波器应用**：PNG使用不同类型的滤波器（如Sub、Up、Average等）来预处理图像数据。这些滤波器通过计算当前像素与其邻近像素的差异来工作，这有助于后续的压缩算法更高效地压缩图像数据。

2. Deflate压缩

实际的压缩是通过Deflate算法实现的，这是一种结合了LZ77算法和霍夫曼编码的复合压缩技术：

- **LZ77算法**：这是一种基于字典的压缩技术，它查找文件中重复的字符串序列，并用较短的引用来替代这些序列。这些引用指向之前已经出现过的数据片段，从而减少数据的冗余度。
- **霍夫曼编码**：在LZ77处理后，霍夫曼编码用于进一步压缩数据。这是一种统计编码技术，它为常见的数据片段分配较短的编码，为不常见的数据片段分配较长的编码。这种方法基于字符出现的频率来构造最优的前缀编码树。



## css实现一个三角形

利用上下左右不同的边框宽度 颜色 不同的三角形 梯形

```css
div {
    width: 0;
    heigt: 0;
    border: 10px solid red;
    border-top-color: transparent;
    border-left-color: transparent;
    border-right-color: transparent;
}
```



## 清除浮动

### 1. 使用 `clear` 属性
```css
.clearfix {
    clear: both;
    height: 0;
    overflow: hidden;
}
```
**原理**：通过添加一个额外的元素（通常是空的div），并应用`clear: both;`属性来阻止其与前面的浮动元素同行显示。设置`height: 0`和`overflow: hidden`是为了确保这个清除元素不占用额外空间。

**优点**：
- 简单直接，易于理解和实现。
- 兼容性好，适用于所有浏览器。

**缺点**：
- 需要添加额外的HTML元素，可能会使HTML结构显得冗余。

### 2. 给浮动元素父级设置高度
```css
.parent {
    height: specific-height; /* 需要具体的高度值 */
}
```
**原理**：直接指定父容器的高度，以包含浮动的子元素。

**优点**：
- 对于已知内容高度的布局，这种方法非常简单有效。

**缺点**：
- 父容器的高度需要提前知道，缺乏灵活性。
- 如果内容动态变化，固定高度可能导致内容溢出或空间浪费。

### 3. 父级元素设置 `overflow: hidden`
```css
.parent {
    overflow: hidden;
}
```
**原理**：`overflow: hidden`不仅隐藏溢出的内容，也会触发块格式化上下文（BFC），这意味着父容器会自动扩展以包含其浮动的子元素。

**优点**：
- 无需添加额外的标记。
- 灵活，适用于内容动态变化的情况。

**缺点**：
- 如果子元素需要超出其父元素的边界显示（如下拉菜单），可能会被意外剪切。

### 4. 万能消除法：`::after`伪元素清浮动
```css
.parent::after {
    content: "";
    display: block;
    clear: both;
}
```
**原理**：通过在父元素的最后添加一个伪元素，并设置`clear: both`来清除浮动。这样，父元素会包围所有浮动子元素。

**优点**：
- 不需要在HTML中添加额外的元素。
- 灵活且干净，是目前最推荐的方式。

**缺点**：
- 在旧版IE浏览器中可能需要特殊的兼容性处理。



## css3新增了什么东西

### 1. 选择器
CSS3 增加了更多复杂和有用的选择器，提高了样式规则的精确性和灵活性。例如：
- **属性选择器**（如 `[type="text"]`）增强，支持子串匹配选择器（如 `^=`、`$=`、`*=`）。
- **结构伪类**（如 `:nth-child`、`:nth-last-child`、`:last-child`、`:first-of-type`），使得基于文档结构的样式应用变得更为简单。

### 2. 盒子模型
- **`border-radius`**：允许创建圆角边框，不再需要借助图像或其他hack。
- **`box-shadow`**：在盒子模型上添加阴影效果，支持多重阴影。
- **`border-image`**：允许使用图片作为边框，可以创建更复杂的边框效果。

### 3. 背景
- **`background-size`**：控制背景图片的尺寸，使背景图像更加灵活（如 `cover`、`contain`）。
- **`background-origin`** 和 **`background-clip`**：定义背景图片的定位区域和绘制区域，提供更多控制背景渲染的方式。

### 4. 文本效果
- **`text-shadow`**：在文字上添加阴影，增强文本的视觉效果。
- **`word-wrap`**（现在称为 `overflow-wrap`）：控制长单词或 URL 地址是否断行，改善布局。

### 5. 渐变
- **线性渐变**（`linear-gradient`）和 **径向渐变**（`radial-gradient`）：用于创建色彩渐变的背景图像，从而无需使用图片文件。

### 6. 字体
- **`@font-face`**：允许网页设计师使用自定义字体文件，网页可以加载和使用在线字体，极大地增强了设计的灵活性。

### 7. 2D/3D变换
- **`transform`**：支持旋转（`rotate`）、缩放（`scale`）、倾斜（`skew`）和移动（`translate`）等2D和3D变换。
- **`transform-origin`**：改变变换元素的原点，为复杂的动画和布局提供支持。

### 8. 过渡与动画
- **`transition`**：为元素之间的状态变化提供平滑的过渡效果。
- **`@keyframes`** 和 **`animation`**：定义复杂的动画序列，控制动画的中间状态，持续时间，以及动画的重复行为。

### 9. 媒体查询
- **媒体查询**：允许CSS根据不同的设备特性（如屏幕尺寸、分辨率、颜色能力等）应用不同的样式规则，是响应式设计的基础。

### 10. 多列布局
- **`column-count`**、**`column-gap`**、**`column-rule`**等属性：使文本分布在多列中显示，简化了杂志式布局的实现。



















